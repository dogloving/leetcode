```
class Solution {
public:
    int findDerangement(int n) {
        if(n == 1)return 0;
        long long a = 0,b = 1;
        int i = 2;
        while(i != n){
            int tmp = b;
            b = (a+b)*i;
            a = tmp;
            ++i;
            b %= 1000000007;
            a %= 1000000007;
        }
        return b;
    }
};
```
<pre>这题的思路比较清晰，用到了排列组合中的知识。我们先确定第一个元素，即我们将第1个元素与后面n-1个元素中的任何一个交换，有n-1中可能。现在假设原先第
1个元素交换到了第i个位置，那么现在有两种可能，原先的第1个元素，即现在的第i个元素可以保持不动或者继续和另外的除第1和第i个位置的n-2个元素交换，而原先第i
个元素(即现在的第1个元素)的位置已经确定下来了。如果保持不动的话，因为剩余的n-2个元素还是在原先的位置，所以有f(n-2)中可能；如果继续动的话，又有n-2种
可能。然后下面的依次类推，到最后只剩下两个元素的时候就是只有一种排列方式了。所以最后的公式为
<code>f(n) = (n-1)*[f(n-2)+(n-2)*[...[2*f(2)]]]</code>
所以我们可以从里往外推，最后推出f(n)，上面的代码就是从里往外推出来的。
</pre>
