```javascript
/**
 * @param {number[]} nums
 * @return {number}
 */
var waysToMakeFair = function(nums) {
    let n = nums.length
    if (n==1) return 1
    if (n==2) return 0
    let s = [nums[0], nums[1]]
    for (let i = 2; i < n; i++) s.push(nums[i]+s[i-2])
    let res = 0
    for (let i = 0; i < n; i+=2) {
        // left of i
        let even = (i-2>=0?s[i-2]:0)
        let odd = (i-1>=0?s[i-1]:0)
        // right of i
        if ((n-1)%2==1) {
            even += (n-1>i?(s[n-1]-(i-1>=0?s[i-1]:0)):0)
            odd += (n-2>i?(s[n-2]-s[i]):0)
        } else {
            even += (n-2>i?(s[n-2]-(i-1>=0?s[i-1]:0)):0)
            odd += (n-1>i?(s[n-1]-s[i]):0)
        }
        if (odd==even) res++
    }
    for (let i = 1; i < n; i+=2) {
        // left of i
        let even = (i-1>=0?s[i-1]:0)
        let odd = (i-2>=0?s[i-2]:0)
        // right of i
        if ((n-1)%2==1) {
            even += (n-1>i?(s[n-1]-s[i]):0)
            odd += (n-2>i?(s[n-2]-(i-1>=0?s[i-1]:0)):0)
        } else {
            even += (n-2>i?(s[n-2]-s[i]):0)
            odd += (n-1>i?(s[n-1]-(i-1>=0?s[i-1]:0)):0)
        }
        if (odd==even) res++
    }
    return res
};
```

题意：我们给你一个整数数组nums，你可以准确地选择一个索引(0-索引)并删除元素。你可以精确地选择一个索引(0-索引)并删除元素。请注意，删除后元素的索引可能会改变。

例如，如果nums = [6,1,7,4,1]。

选择删除索引1的结果是nums = [6,7,4,1].
选择删除索引2的结果是nums=[6,1,4,1]。
选择删除索引4的结果是nums=[6,1,7,4]。
如果奇数索引值之和等于偶数索引值之和，则数组是公平的。

返回可以选择的索引数，这样在删除索引后，nums是公平的。

思路：分两种情况讨论：

1. 数组长度为偶数，如0,1,2,3,4,5,...,99。

   1. 删除第偶数个，如删除第4个。

      偶数之和为0,2,  5,7,...,99

      奇数之和为1,3,   6,8,...,98

   2. 删除第奇数个，如删除第5个。

      偶数之和为0,2,4,   7,9,...,99

      奇数之和为1,3,   6,8,,...98

2. 数组长度为奇数，如0,1,2,3,4,5,...,100

   1. 删除第偶数个，如删除第4个。

      偶数之和为0,2,   5,7,...,99,

      奇数之和为1,3,   6,8,...,100

   2. 删除第奇数个，如删除第5个。

      偶数之和为0,2,4,   7,9,...,99

      奇数之和为1,3,   6,8,...,100